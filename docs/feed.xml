<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://ui-testing.academy/feed.xml" rel="self" type="application/atom+xml" /><link href="https://ui-testing.academy/" rel="alternate" type="text/html" hreflang="en" /><updated>2020-09-10T19:44:43+00:00</updated><id>https://ui-testing.academy/feed.xml</id><title type="html">UI Testing Academy</title><subtitle>UI Testing related content</subtitle><author><name>Alex Zhukovich</name></author><entry><title type="html">All test cases should be independent</title><link href="https://ui-testing.academy/general/good-practices/all-test-cases-should-be-independent/" rel="alternate" type="text/html" title="All test cases should be independent" /><published>2020-09-06T00:00:00+00:00</published><updated>2020-09-06T00:00:00+00:00</updated><id>https://ui-testing.academy/general/good-practices/all-test-cases-should-be-independent</id><content type="html" xml:base="https://ui-testing.academy/general/good-practices/all-test-cases-should-be-independent/">&lt;p&gt;A test case checks that part of the application works according to requirements. When we have a situation where one test case depends on the other one, we may see unexpected behavior in some test cases because of the following reasons:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;test cases may be executed in random sequence; in this case, some test cases could fail because of the incorrect initial state of the application or environment&lt;/li&gt;
  &lt;li&gt;failing one test could cause another test to fail too&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Many testing frameworks have a way to execute methods before and after the test case. In the case of JUnit 5, we can annotate methods with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@BeforeEach&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@AfterEach&lt;/code&gt; methods.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SuperImportantTestSuite&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

   &lt;span class=&quot;nd&quot;&gt;@BeforeEach&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setUp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// set up data before each test case&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 

   &lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;importantTestCase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


   &lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;superImportantTestCase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;nd&quot;&gt;@AfterEach&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tearDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// clean up data after each test case&lt;/span&gt;
      &lt;span class=&quot;nf&quot;&gt;clearDatabase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Using methods with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@BeforeEach&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@AfterEach&lt;/code&gt; annotations from JUnit 5, or similar functionalities from other frameworks we can make our test cases independent. So, we can clean up data before or after each test scenario. In this case, every test case will start from the same state. In this example, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;importantTestCase&lt;/code&gt; and the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;superImportantTestCase&lt;/code&gt; will start with an empty database.&lt;/p&gt;</content><author><name>alex_zhukovich</name></author><summary type="html">A test case checks that part of the application works according to requirements. When we have a situation where one test case depends on the other one, we may see unexpected behavior in some test cases because of the following reasons: test cases may be executed in random sequence; in this case, some test cases could fail because of the incorrect initial state of the application or environment failing one test could cause another test to fail too</summary></entry><entry><title type="html">Approaches of UI testing</title><link href="https://ui-testing.academy/general/ui-testing/approaches-of-ui-testing/" rel="alternate" type="text/html" title="Approaches of UI testing" /><published>2020-09-06T00:00:00+00:00</published><updated>2020-09-06T00:00:00+00:00</updated><id>https://ui-testing.academy/general/ui-testing/approaches-of-ui-testing</id><content type="html" xml:base="https://ui-testing.academy/general/ui-testing/approaches-of-ui-testing/">&lt;p&gt;UI Testing can be done in the following ways:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Manual testing&lt;/li&gt;
  &lt;li&gt;Record and replay testing&lt;/li&gt;
  &lt;li&gt;Model-based testing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Manual testing&lt;/strong&gt; is a type of software testing in which a tester performs actions for interaction with applications to check whether the software product is functioning correctly and meets all requirements. All test cases are executed manually without using any automated tools.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Pros
    &lt;ul&gt;
      &lt;li&gt;Does not require programming or automation knowledge&lt;/li&gt;
      &lt;li&gt;Helps to find critical bugs in the application&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Cons
    &lt;ul&gt;
      &lt;li&gt;It is a time-consuming approach&lt;/li&gt;
      &lt;li&gt;Quality depends on the capabilities of the tester/testing team, the quality of the requirements and the timeframe.&lt;/li&gt;
      &lt;li&gt;Usually, all test cases cannot be covered because of the size of the application or the timeframe.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Record and Replay&lt;/strong&gt; testing is a type of software testing in which a human record set of actions with automation tools and later on, these steps can be reproduced. Future runs can use various data sets for test cases.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Pros
    &lt;ul&gt;
      &lt;li&gt;Does not require programming and automation knowledge&lt;/li&gt;
      &lt;li&gt;Can be used as a transition tool from manual to automation testing approach&lt;/li&gt;
      &lt;li&gt;Can be used as an educational tool for learning the testing framework&lt;/li&gt;
      &lt;li&gt;Can be used as a tool for generating test cases before refactoring internal implementations&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Cons
    &lt;ul&gt;
      &lt;li&gt;Recorded test cases can be broken after minor changes in the application’s behavior, and often test cases should be recorded from the very beginning&lt;/li&gt;
      &lt;li&gt;Recorded test cases can be broken after network speed changes because such tools usually record a “waiting time”&lt;/li&gt;
      &lt;li&gt;Sometimes such tools generate unreadable and unmaintainable code, like Espresso Test Recorder&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Model-based testing&lt;/strong&gt; is a type of software testing in which a model of the software product will be created initially. The model is a description of system behavior. Usually, such models help to fully understand an application or feature that simplifies creating efficient test cases that can be automated.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Pros
    &lt;ul&gt;
      &lt;li&gt;Allows creating highly efficient test cases&lt;/li&gt;
      &lt;li&gt;Helps achieve high test coverage&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Cons
    &lt;ul&gt;
      &lt;li&gt;Requires programming skills&lt;/li&gt;
      &lt;li&gt;It requires more time to implement the test suite&lt;/li&gt;
      &lt;li&gt;The detailed model should be created before creating test cases&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>alex_zhukovich</name></author><summary type="html">UI Testing can be done in the following ways: Manual testing Record and replay testing Model-based testing</summary></entry><entry><title type="html">Naming conventions for test cases</title><link href="https://ui-testing.academy/general/naming/naming-conventions-for-test-cases/" rel="alternate" type="text/html" title="Naming conventions for test cases" /><published>2020-09-06T00:00:00+00:00</published><updated>2020-09-06T00:00:00+00:00</updated><id>https://ui-testing.academy/general/naming/naming-conventions-for-test-cases</id><content type="html" xml:base="https://ui-testing.academy/general/naming/naming-conventions-for-test-cases/">&lt;p&gt;A name is an essential part of a test suite and each test scenario. When analyzing test reports, all you see are the names of the test cases. The right name of the test case provides information about the scenario, and often, it’s enough information for understanding the main idea.&lt;/p&gt;

&lt;p&gt;Many naming conventions can be applied to test cases.&lt;/p&gt;

&lt;p&gt;Note: Some runtime environments allow you to use space &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot; &quot;&lt;/code&gt; as a separator inside test names; in other cases, one of the most popular options is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;_&quot;&lt;/code&gt;. Example:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;should_showInvalidAuthenticationMessage_when_passwordIsInvalid
// or
should show authentication message when password is invalid
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Most used naming conventions for test cases:&lt;/p&gt;
&lt;h2 id=&quot;feature-which-will-be-tested&quot;&gt;Feature which will be tested&lt;/h2&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;success_to_paid_for_order&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;fail_to_login_if_account_is_invalid&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;fail_to_apply_invalid_voucher&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;action-state-under-test-expected-behavior&quot;&gt;[Action] [State under test] [Expected behavior]&lt;/h2&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;pay_validAccount_openSuccessScreen&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;login_invalidAccount_showInvalidUserMessage&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;addVoucher_invalidVoucher_showInvalidVoucherMessage&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;action-expected-behavior-state-under-test&quot;&gt;[Action] [Expected behavior] [State under test]&lt;/h2&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;pay_openSuccessScreen_when_AccountIsValid&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;login_showInvalidUserMessage_when_AccountIsInvalid&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;addVoucher_showInvalidVoucherMessage_when_VoucherIsInvalid&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;should-expected-behavior-when-state-under-test&quot;&gt;Should [Expected behavior] When [State under test]&lt;/h2&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;should_openSuccessScreen_when_userPayWithValidAccount&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;should_showInvalidUserMessage_when_loginWithInvalidAccount&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;should_showInvalidVoucherMessage_when_userAddInvalidVoucher&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;given-preconditions-when-state-under-test-then-expected-behavior&quot;&gt;Given [Preconditions] When [State under test] Then [Expected behavior]&lt;/h2&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;given_userIsAuthenticated_when_accountNumberIsValidToPay_then_openSuccessScreen&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;given_userIsNotAuthenticated_when_invalidAccountToLogin_then_showInvalidVoucherMessage&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;given_userIsAuthenticated_when_addInvalidVoucher_then_showInvalidVoucherMessage&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>alex_zhukovich</name></author><summary type="html">A name is an essential part of a test suite and each test scenario. When analyzing test reports, all you see are the names of the test cases. The right name of the test case provides information about the scenario, and often, it’s enough information for understanding the main idea.</summary></entry></feed>